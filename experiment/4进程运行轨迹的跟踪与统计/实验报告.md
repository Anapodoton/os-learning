### 1 . 代码修改

> **切换点的修改**
> 进程状态一共有五种 新建(N)、进入就绪态(J)、进入运行态(R)、进入阻塞态(W)和退出(E)
>
> - *N->J* 此两种状态的产生和切换都在fork对应的copy_process函数中，我认为分N,J有点多余，这俩种状态几乎是同时产生的。
> - *J->R* 在sched.c 文件中的schedule 函数中进行，除了0号进程，任何其他进程都是由schedule函数中切换到R状态，并获得CPU资源。
> - *R->W* main函数中Task 0 强制调用sys_pause 将自己睡眠; 如果进程等待资源也将主动调用sleep_on函数，将自己切换到W，wait函数中父进程主动睡眠。
> - *W->J* 主动唤醒wakeup函数，在schedule 函数中，会检测中断唤醒进程。
> - *R->E* 进程结束后，会主动调用exit函数，来释放资源，并将状态置为W。

> 几点注意的， schedule 函数中可能会切换的是正在运行的进程自己，比方说0进程强制睡眠自己，进行schedule 时发现无进程可切，只能运行自己，此时不需要切换状态 schedule 函数中调度算法会让目标next初始化位0,当没有进程可以调度时，就会切到task 0的tss。

### 2. 源码粘贴

- #### main.c

  ```
  void main(void)        /* This really IS void, no error here. */
  {            /* The startup routine assumes (well, ...) this */
  /*
  * Interrupts are still disabled. Do necessary setups, then
  * enable them
  */
     ROOT_DEV = ORIG_ROOT_DEV;
     drive_info = DRIVE_INFO;
    memory_end = (1<<20) + (EXT_MEM_K<<10);
    memory_end &= 0xfffff000;
    if (memory_end > 16*1024*1024)
        memory_end = 16*1024*1024;
    if (memory_end > 12*1024*1024) 
        buffer_memory_end = 4*1024*1024;
    else if (memory_end > 6*1024*1024)
        buffer_memory_end = 2*1024*1024;
    else
        buffer_memory_end = 1*1024*1024;
    main_memory_start = buffer_memory_end;
  #ifdef RAMDISK
    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
  #endif
    mem_init(main_memory_start,memory_end);
    trap_init();
    blk_dev_init();
    chr_dev_init();
    tty_init();
    time_init();
    sched_init();
    buffer_init(buffer_memory_end);
    hd_init();
    floppy_init();
    sti();
    move_to_user_mode();
    setup((void*)& drive_info);
    (void)open("/dev/tty0", O_RDWR, 0);    //建立文件描述符0和/dev/tty0的关联
    (void)dup(0);        //文件描述符1也和/dev/tty0关联
    (void)dup(0);        //文件描述符2也和/dev/tty0关联
    (void)open("/var/process.log", O_CREAT | O_TRUNC | O_WRONLY, 0666);
    if (!fork()) {        /* we count on this going ok */
        init();
    }
  /*
  *   NOTE!!   For any other task 'pause()' would mean we have to get a
  * signal to awaken, but task0 is the sole exception (see 'schedule()')
  * as task 0 gets activated at every idle moment (when no other tasks
  * can run). For task0 'pause()' just means we go check if some other
  * task can run, and if not we return here.
  */
    for(;;) pause();
  }
  ```

- #### printk.c

  ```
  static char logbuf[1024];
  int fprintk(int fd, const char* fmt, ...)
  {
    va_list args;
    int count;
    struct file* file;
    struct m_inode* inode;
  
    va_start(args, fmt);
    count = vsprintf(logbuf, fmt, args);
    va_end(args);
  
    if (fd < 3)    /* 如果输出到stdout或stderr，直接调用sys_write即可 */
    {
        __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $logbuf\n\t" /* 注意对于Windows环境来说，是_logbuf,下同 */
            "pushl %1\n\t"
            "call sys_write\n\t" /* 注意对于Windows环境来说，是_sys_write,下同 */
            "addl $8,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count), "r" (fd) : "ax", "cx", "dx");
    }
    else    /* 假定>=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/
    {
        if (!(file = task[0]->filp[fd]))    /* 从进程0的文件描述符表中得到文件句柄 */
            return 0;
        inode = file->f_inode;
  
        __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $logbuf\n\t"
            "pushl %1\n\t"
            "pushl %2\n\t"
            "call file_write\n\t"
            "addl $12,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count), "r" (file), "r" (inode) : "ax", "cx", "dx");
    }
    return count;
  }
  ```

- #### fork.c 文件

  ```
  int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
        long ebx,long ecx,long edx,
        long fs,long es,long ds,
        long eip,long cs,long eflags,long esp,long ss)
  {
    struct task_struct *p;
    int i;
    struct file *f;
  
    p = (struct task_struct *) get_free_page();
    if (!p)
        return -EAGAIN;
    fprintk(3, "%ld\t%c\t%ld\n", last_pid, 'N', jiffies);
    task[nr] = p;
    *p = *current;    /* NOTE! this doesn't copy the supervisor stack */
    p->state = TASK_UNINTERRUPTIBLE;
    p->pid = last_pid;
    p->father = current->pid;
    p->counter = p->priority;
    p->signal = 0;
    p->alarm = 0;
    p->leader = 0;        /* process leadership doesn't inherit */
    p->utime = p->stime = 0;
    p->cutime = p->cstime = 0;
    p->start_time = jiffies;
    p->tss.back_link = 0;
    p->tss.esp0 = PAGE_SIZE + (long) p;
    p->tss.ss0 = 0x10;
    p->tss.eip = eip;
    p->tss.eflags = eflags;
    p->tss.eax = 0;
    p->tss.ecx = ecx;
    p->tss.edx = edx;
    p->tss.ebx = ebx;
    p->tss.esp = esp;
    p->tss.ebp = ebp;
    p->tss.esi = esi;
    p->tss.edi = edi;
    p->tss.es = es & 0xffff;
    p->tss.cs = cs & 0xffff;
    p->tss.ss = ss & 0xffff;
    p->tss.ds = ds & 0xffff;
    p->tss.fs = fs & 0xffff;
    p->tss.gs = gs & 0xffff;
    p->tss.ldt = _LDT(nr);
    p->tss.trace_bitmap = 0x80000000;
    if (last_task_used_math == current)
        __asm__("clts ; fnsave %0"::"m" (p->tss.i387));
    if (copy_mem(nr,p)) {
        task[nr] = NULL;
        free_page((long) p);
        return -EAGAIN;
    }
    for (i=0; i<NR_OPEN;i++)
        if ((f=p->filp[i]))
            f->f_count++;
    if (current->pwd)
        current->pwd->i_count++;
    if (current->root)
        current->root->i_count++;
    if (current->executable)
        current->executable->i_count++;
    set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
    set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
    p->state = TASK_RUNNING;    /* do this last, just in case */
    fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'J', jiffies);
    return last_pid;
  }
  ```

- #### sched.c

  ```
  void schedule(void)
  {
    int i,next,c;
    struct task_struct ** p;
  /* check alarm, wake up any interruptible tasks that have got a signal */
    for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
        if (*p) {
            if ((*p)->alarm && (*p)->alarm < jiffies) {
                    (*p)->signal |= (1<<(SIGALRM-1));
                    (*p)->alarm = 0;
                }
            if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
                (*p)->state == TASK_INTERRUPTIBLE)
            {
                (*p)->state = TASK_RUNNING;
                fprintk(3, "%ld\t%c\t%ld\n", (*p)->pid, 'J', jiffies);
            }
        }
  /* this is the scheduler proper: */
  
    while (1) {
        c = -1;
        next = 0;
        i = NR_TASKS;
        p = &task[NR_TASKS];
        while (--i) {
            if (!*--p)
                continue;
            if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
                c = (*p)->counter, next = i;
        }
        if (c) break;
        for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
            if (*p)
                (*p)->counter = ((*p)->counter >> 1) +
                        (*p)->priority;
    }
    if (current->pid != task[next]->pid)
    {
        if (current->state == TASK_RUNNING)
            fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
        fprintk(3, "%ld\t%c\t%ld\n", task[next]->pid, 'R', jiffies);
    }
    switch_to(next);
  }
  int sys_pause(void)
  {
    if (current->state != TASK_INTERRUPTIBLE)
        fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    current->state = TASK_INTERRUPTIBLE;
    schedule();
    return 0;
  }
  void sleep_on(struct task_struct **p)
  {
    struct task_struct *tmp;
    if (!p)
        return;
    if (current == &(init_task.task))
        panic("task[0] trying to sleep");
    tmp = *p;
    *p = current;
    current->state = TASK_UNINTERRUPTIBLE;
    fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    schedule();
    if (tmp)
    {
        tmp->state = 0;
        fprintk(3, "%ld\t%c\t%ld\n", tmp->pid, 'J', jiffies);
    }
  }
  void interruptible_sleep_on(struct task_struct **p)
  {
    struct task_struct *tmp;
    if (!p)
        return;
    if (current == &(init_task.task))
        panic("task[0] trying to sleep");
    tmp=*p;
    *p=current;
  repeat:    current->state = TASK_INTERRUPTIBLE;
    fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    schedule();
    if (*p && *p != current) {
        (**p).state=0;
        fprintk(3, "%ld\t%c\t%ld\n",(**p).pid, 'J', jiffies);
        goto repeat;
    }
    *p=NULL;
    if (tmp)
    {
        tmp->state = 0;
        fprintk(3, "%ld\t%c\t%ld\n", tmp->pid, 'J', jiffies);
    }
  }
  void wake_up(struct task_struct **p)
  {
    if (p && *p) {
        (**p).state=0;
        fprintk(3, "%ld\t%c\t%ld\n", (**p).pid, 'J', jiffies);
        *p=NULL;
    }
  }
  ```

- #### exit.c

  ```
  int do_exit(long code)
  {
    int i;
    free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
    free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
    for (i=0 ; i<NR_TASKS ; i++)
        if (task[i] && task[i]->father == current->pid) {
            task[i]->father = 1;
            if (task[i]->state == TASK_ZOMBIE)
                /* assumption task[1] is always init */
                (void) send_sig(SIGCHLD, task[1], 1);
        }
    for (i=0 ; i<NR_OPEN ; i++)
        if (current->filp[i])
            sys_close(i);
    iput(current->pwd);
    current->pwd=NULL;
    iput(current->root);
    current->root=NULL;
    iput(current->executable);
    current->executable=NULL;
    if (current->leader && current->tty >= 0)
        tty_table[current->tty].pgrp = 0;
    if (last_task_used_math == current)
        last_task_used_math = NULL;
    if (current->leader)
        kill_session();
    current->state = TASK_ZOMBIE;
    current->exit_code = code;
    fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'E', jiffies);
    tell_father(current->father);
    schedule();
    return (-1);    /* just to suppress warnings */
  }
  int sys_exit(int error_code)
  {
    return do_exit((error_code&0xff)<<8);
  }
  int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)
  {
    int flag, code;
    struct task_struct ** p;
    verify_area(stat_addr,4);
  repeat:
    flag=0;
    for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
        if (!*p || *p == current)
            continue;
        if ((*p)->father != current->pid)
            continue;
        if (pid>0) {
            if ((*p)->pid != pid)
                continue;
        } else if (!pid) {
            if ((*p)->pgrp != current->pgrp)
                continue;
        } else if (pid != -1) {
            if ((*p)->pgrp != -pid)
                continue;
        }
        switch ((*p)->state) {
            case TASK_STOPPED:
                if (!(options & WUNTRACED))
                    continue;
                put_fs_long(0x7f,stat_addr);
                return (*p)->pid;
            case TASK_ZOMBIE:
                current->cutime += (*p)->utime;
                current->cstime += (*p)->stime;
                flag = (*p)->pid;
                code = (*p)->exit_code;
                release(*p);
                put_fs_long(code,stat_addr);
                return flag;
            default:
                flag=1;
                continue;
        }
    }
    if (flag) {
        if (options & WNOHANG)
            return 0;
        current->state=TASK_INTERRUPTIBLE;
        fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
        schedule();
        if (!(current->signal &= ~(1<<(SIGCHLD-1))))
            goto repeat;
        else
            return -EINTR;
    }
    return -ECHILD;
  }
  ```

- #### process.c

  ```
  int main(int argc, char * argv[])
  {
    int state;
    if (!fork())
    {
        cpuio_bound(10, 1, 0);
        return 0;
    }
    if (!fork())
    {
        cpuio_bound(10, 0, 1);
        return 0;
    }    
    if (!fork())
    {
        cpuio_bound(10, 1, 1);
        return 0;
    }
    if (!fork())
    {
        cpuio_bound(10, 1, 9);
        return 0;
    }
    wait(&state);
    return 0;
  }
  ```

## 3. 实验结果

- process log![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid523698-20190605-1559705258342)

- 分析后的日志

   

  

  ## 4. 时间片的修改

  > 除了0，其他process的counter都继承自父进程的priority ，所以修改task 0的priority 既可以修改其子进程的时间片，而task 0 是在sche.h中定义的，所以修改sched.h 文件即可。
  >
  > ```
  > INIT_TASK \
  > /* state etc */    { 0,15,80, \
  > /* signals */    0,{{},},0, \
  > /* ec,brk... */    0,0,0,0,0,0, \
  > /* pid etc.. */    0,-1,0,0,0, \
  > /* uid etc */    0,0,0,0,0,0, \
  > /* alarm */    0,0,0,0,0,0, \
  > /* math */    0, \
  > /* fs info */    -1,0022,NULL,NULL,NULL,0, \
  > /* filp */    {NULL,}, \
  >   { \
  >       {0,0}, \
  > /* ldt */    {0x9f,0xc0fa00}, \
  >       {0x9f,0xc0f200}, \
  >   }, \
  > /*tss*/    {0,PAGE_SIZE+(long)&init_task,0x10,0,0,0,0,(long)&pg_dir,\
  >    0,0,0,0,0,0,0,0, \
  >    0,0,0x17,0x17,0x17,0x17,0x17,0x17, \
  >    _LDT(0),0x80000000, \
  >       {} \
  >   }, \
  > }
  > ```
  >
  > 将时间片定义为 80即800毫秒
  > 运行如下 ![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid523698-20190605-1559707137343)vi