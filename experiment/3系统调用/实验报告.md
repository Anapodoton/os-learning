## 实验过程

### 1.创建实验环境

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511654817519-wm)

### 2.在`include/unistd.h`中添加调用号NR_whoami和NR_iam，声明函数原型

#define __NR_iam 72
#define __NR_whoami 73

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511654968479-wm)

int iam(const char *name);

int whoami(char *name,unsigned int size);

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511655087483-wm)

### 3.在`kernel/system_call.s`中修改系统调用总数

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511655220049-wm)

### 4.在`include/linux/sys.h`中做修改

extern int sys_iam();

extern int sys_whoami();

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511655399462-wm)

### 5.在`linux-0.11/kernel/`中实现who.c

```c
#define _LIBRARY_
#include<unisted.h>
#include<errno.h>
#include<asm/segment.h>
char username[64]={0};
int sys_iam(const char *name)
{
	int result=0,cnt;
          while(get_fs_byte(name+result)!='\0'&&result<64)
        result++;
    if(result>23) return -EINVAL;
    for(cnt=0;cnt<=result;cnt++){
        username[cnt]=get_fs_byte(name+cnt);
    }
    return result;
}
int sys_whoami(char *name, unsigned int size)
{
	int result=0,cnt;
    while(username[result]!='\0'&&result<64)
        result++;
    if(result>size) return -EINVAL;
    for(cnt =0;cnt<=result;++cnt)
        put_fs_byte(username[cnt],name+cnt);
    return result;
}
```



### 6.在/kernel/中修改Makefile

who.o

who.s who.o:who.c ../include/linux/kernel.h ../include/unistd.h

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511657638152-wm)

### 7.运行make all命令

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511657912706-wm)

### 8.接下来要在Ubuntu中访问linux-0.11，在磁盘中挂载虚拟机

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511658046580-wm)

### 9.文件复制

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511658509772-wm)（1）复制`oslab/linux-0.11/include/unistd.h`文件到`oslab/hdc/usr/include/`

（2）复制`oslab/linux-0.11/include/linux/sys.h`文件到`oslab/hdc/usr/include/linux/`

### 10.在 `oslab/hdc/usr/root`编写测试文件iam.c和whoami.c

iam.c

```c
#define _LIBRARY_
#include<unisted.h>
#include<errno.h>
#include<asm/segment.h>
_syscall1(int,iam,const char*,name)
int main(int argc, char *argv[])
{
    if(argc>1&&iam(argv[1])>=0)
        return 0;
    return -1;
}
```

whoami.c

```c
#define _LIBRARY_
#include<unisted.h>
#include<errno.h>
#include<asm/segment.h>
#include<stdio.h>
int main(void)
{
    char name[64];
    int r=whoami(name, 24);
    if(r<0)
        return -1;
    printf("%s\n",name);
    return 0;
}
```

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511659867450-wm)![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511660476833-wm)

### 11.复制`/home/teacher/`中testlab2.c和testlab2.sh到`oslab/hdc/usr/root`

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511660613923-wm)

### 12.取消虚拟机挂载

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511660863765-wm)

### 13.运行如下编译指令

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511661009626-wm)

### 14.输入./iam kagura和./whoami

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511661163016-wm)

### 15.输入./testlab2

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511661267360-wm)

### 16.增加权限后，输入./testlab2.sh

![实验楼](https://dn-simplecloud.shiyanlou.com/5633351511661522959-wm)

## **实验问题**

### 1. 从Linux 0.11现在的机制看，它的系统调用最多能传递几个参数？你能想出办法来扩大这个限制吗？

答：系统调用通过eax传递系统调用号，通过ebx, ecx, edx三个寄存器传递参数，故最多能传递3个。 （1）通过堆栈传递参数 （2）把寄存器分成高位和低位部分，可传递多个较小参数 （3）传递一个指针，该指针指向一个较大的数据结构，如数组或链表，里面存放所需参数，通过寄存器来间接寻址

### 2.用文字简要描述向Linux 0.11添加一个系统调用foo()的步骤。

答：假定foo()返回类型为int （1）在include/unistd.h中添加系统调用号__NR_foo，声明函数原型int foo() （2）在kernel/system_call.s中函数调用总数nr_system_calls数量+1 （3）在include/linux/sys.h中做修改，声明extern int foo();，并在该文件的fn_ptr sys_call_table[]数组中加上一项sys_foo （4）在linux-0.11/kernel/中实现foo.c （5）在Makefile的OBJS中加入foo.o，并添加生成foo.s、foo.o的依赖规则