# bootsect.s

1. 切换至oslab, 并解压缩oslab

   ```
   cd oslab
   tar zxvf <hit-oslab-linux-20110823.tar.gz>
   ```

2. 进入解压出来的oslab/linux-0.11，并编译

   ```
   cd oslab/linux-0.11
   make all
   ```

3. 回到上一级目录(现在是～/oslab/oslab)，启动bochs

   ```
   cd ..
   ./run
   ```

   我们看到成功运行了linux-0.11系统

   ![å¾çæè¿°](https://dn-simplecloud.shiyanlou.com/courses/uid1076110-20190622-1561188267959)

4. 尝试修改bootsect.s，将loading system改为别的东西 进入linux-0.11/boot目录，用vim打开bootsect.s，找到#msg1字段，直接修改即可，记得将cx改为修改后的字数。

5. 编译和链接bootsect.s, 并去掉多出来的32字节

   ```
   as86 -0 -a -o bootsect.o bootsect.s
   ld -0 -s -o bootsect bootsect.o
   dd bs=1 if=bootsect of=Image skip=32
   ```

6. 将得到的Image文件替换到上一级目录，记得提前备份，在～/oslab/oslab目录下运行bochs

   ```
   cd ../Image ../Image.bak
   cd Image ../Image
   cd ..
   cd ..
   ./run
   ```

   ![](https://img2018.cnblogs.com/blog/1358741/201906/1358741-20190626140140533-2045288835.png)

   注：不妨用ls -l命令查看Image和Image.bak的大小，实际上我们得到的Image只包含了bootsect模块，当然无法完成完整的启动操作系统，因此后面运行时会停留在打出启动文字这一步。

# 跳转到setup.s，并输出字符

1. 在boot目录中备份原始的setup.s，并copy bootsect.s将其替换为setup.s，删除无关部分，保留显示字符的模块（记得设置es的值，其作为调用int的段地址)

   ```
   SETUPLEN = 2
   BOOTSEG = 0x7c0
   INITSEG = 0X9000
   
   entry start
   start:
   mov ah,#0x03
   xor bh,bh
   int 0x10
   
   mov ax,cs
   mov es,ax
   mov cx,#30
   mov bx,#0x0007
   mov bp,#msg2
   mov ax,#0x1301
   int 0x10
   
   mov ax,#INITSEG
   mov ds,ax
   mov ah,#0x03
   xor bh,bh
   int 0x10
   mov [0],dx
   
   mov ah,#0x88
   int 0x15
   mov [2],ax
   
   mov ax,#0x0000
   mov ds,ax
   lds si,[4*0x41]
   mov ax,#INITSEG
   mov es,ax
   mov di,#0x0004
   mov cx,#0x10
   rep
   movsb
   mov ax,cs
   mov es,ax
   mov ax,#INITSEG
   mov ss,ax
   
   push #cursor
   push #12
   mov bp,sp
   call print_str
   mov bp,#0
   call print_hex
   call print_nl
   push #mem
   push #13
   mov bp,sp
   call print_str
   mov bp,#2
   call print_hex
   call print_nl
   push #cyls
   push #6
   mov bp,sp
   call print_str
   mov bp,#4
   call print_hex
   call print_nl
   push #heads
   push #8
   mov bp,sp
   call print_str
   mov bp,#6
   call print_hex
   call print_nl
   push #sect
   push #10
   mov bp,sp
   call print_str
   mov bp,#0x0e+4
   call print_hex
   call print_nl
   loop_inf:
   jmp loop_inf
   
   cursor:
   .ascii "Cursor POS :"
   mem:
   .ascii "Memory SIZE :"
   cyls:
   .ascii "Cyls :"
   heads:
   .ascii "Heads : "
   sect:
   .ascii "Sectors : "
   
   print_str:
   mov ah,#0x03
   xor bh,bh
   int 0x10
   mov cx,(bp)
   mov bp,(bp+2)
   mov bx,#0x0007
   mov ax,#0x1301
   int 0x10
   ret
   
   print_hex:
   mov cx,#4
   mov dx,(bp)
   print_digit:
   rol dx,#4
   mov ax,#0xe0f
   and al,dl
   add al,#0x30
   cmp al,#0x3a
   jl outp
   add al,#0x07
   outp:
   int 0x10
   loop print_digit
   ret
   
   print_nl:
   mov ax,#0x0e0d
   int 0x10
   mov al,#0xa
   int 0x10
   ret
   
   msg2:
   .byte 13,10
   .ascii "Now setup is running ..."
   .byte 13,10,13,10
   mov cx,#10
   mov bp,#sect
   ```

msg1: .byte 13, 10 .ascii "Now we are in SETUP" .byte 13, 10, 13, 10

.text end text: ```

1. 修改build.c，注释掉178和179行，在linux-0.11目录执行 make BootImage
2. 返回oslab，执行./run ![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1076110-20190622-1561195438977)